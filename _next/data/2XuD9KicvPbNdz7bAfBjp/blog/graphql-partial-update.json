{"pageProps":{"title":"GraphQL Partial Update","content":"\nRecently we decided to use [AWS Amplify](https://aws.amazon.com/amplify) for one of the products weâ€™re currently working on.\n\n[AWS Amplify](https://aws.amazon.com/amplify) promises to provide you with the option to rapidly develop the [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) or a [GraphQL](https://graphql.org/) based backend that's very well integrated with your frontend development - be it a web application or a mobile app. That's at least the marketed value proposition.\n\nI don't wanna say that's [AWS Amplify](https://aws.amazon.com/amplify) is still in its infancy but let's say it's\nnot without its caveats. One of them is the documentation. In general AWS\nprovides a lot of documentation, which doesn't necessarily means that it's\ngood.\n\nUsually the truly technical documentation like the one for AWS SDK is really\ngood, which is not always the case with the Docs for other services. With AWS\nAmplify it's pretty often the case that the documentation is not up-to-date and\nyou have to dig through the GitHub tickets discussions to find the truth or\nthe undocumented features (yes, `@http resolvers` - I look at you)\n\nIf you have to provide custom headers to your HTTP resolver based GraphQL\noperation - you can send them as part of `API.graphql()` call as last\nparameter, e.g.\n\n```js\nconst headers = {\n  foor: 'bar',\n};\n\nconst response = await API.graphql(\n  graphqlOperation(createFooBar, { body }),\n  headers,\n);\n```\n\nBut I'm drifting away ðŸ˜€\n\nOk, so, we decided to go with GraphQL since in the final iterations the product should have more than just a web application and, theoretically, it should be easier to fetch only the data you need due to the flexible nature of [GraphQL](https://graphql.org/).\n\nSo, if you worked with [AWS Amplify](https://aws.amazon.com/amplify/) and [GraphQL](https://graphql.org/) you know that it doesnâ€™t support partial updates, which was a deal-breaker for us, since we have multiple flows where we have to partially push the data to the backend.\n\nAfter a short research online, I found a pretty cool article from [Arnaud BezanÃ§on](https://medium.com/@arnaud.bezancon) here [https://medium.com/workflowgen/graphql-mutations-partial-updates-implementation-bff586bda989](https://medium.com/workflowgen/graphql-mutations-partial-updates-implementation-bff586bda989)\n\nAlthough I really liked his way of doing things, my lazy nature wanted to have a more generic (not necessarily a better) solution though. So, my way of thinking was: since I only send parts of the data to the backend but it expects the whole { input } object from me, I will just merge the existing data with the new one and push it to the backend.\n\nWhat you have to consider as well is that you will have to remove any automatically generated/updated fields from your `json` object â€” in my case `createdAt/updatedAt` fields.\n\nSo, below you see a quick and dirty way of doing it.\n\nPlease, note that Iâ€™m using email as the key of our user model. In addition to that, you will have to always send the whole user object with all the fields to the update mutation â€” meaning when you call `getUser` it should fetch the user object with all the fields.\n\nIn a nutshell - the flow is the following:\n- try to fetch the user from the backend\n- if the user doesn't exist - call `createUser` with the provided data\n- if the user exist - merge the existing data with the new one and call\n  `updateUser`\n\n```js\nimport { API, graphqlOperation } from 'aws-amplify';\nimport { getUser } from '@/graphql/queries';\nimport { createUser, updateUser } from '@/graphql/mutations';\nimport { exclude } from '@/utils/json';\n\nconst get = async (email) => {\n  try {\n    const {\n      data: {\n        getUser: user,\n      },\n    } = await API.graphql(graphqlOperation(getUser, { email }));\n    return user;\n  } catch (error) {\n    throw new Error(error.errors);\n  }\n};\n\nconst createOrUpdate = async (input) => {\n  const { email } = input;\n  try {\n    const user = await get(email);\n    if (!user) {\n      await API.graphql(graphqlOperation(createUser, { input }));\n    } else {\n      // get current user data\n      // and only update the provided values\n      // createdAt, updatedAt have to be excluded\n      const update = { ...exclude(['createdAt', 'updatedAt'], user), ...input };\n      await API.graphql(graphqlOperation(updateUser, { input: update }));\n    }\n  } catch (error) {\n    throw new Error(error.errors);\n  }\n};\n\nexport {\n  get,\n  createOrUpdate,\n};\n```\n\nSince the email is used as the key of the user model, it has to be passed to the `createOrUpdate` function as part of the `{ input }` object. Whenever I have to create or update a user, we have to add the email to the input and then just call `createOrUpdate(input);`\n\n```js\nconst { email } = user;\nconst input = { email, â€¦payload };\n\ntry {\n  ...\n  await createOrUpdate(input);\n  ...\n} catch (error) {\n  throw new Error(error);\n}\n```\n\nItâ€™s not an efficient way of doing things since it will fetch the data from your backend before doing an update but this way you donâ€™t have to do things manually or thing about the values youâ€™d like to be updated.\n\nThatâ€™s all folks.\n"},"__N_SSG":true}