{"pageProps":{"posts":[{"slug":"perfect-startup-team","published":"Tue Apr 27 2021 00:00:00 GMT+0000 (Coordinated Universal Time)","title":"Perfect Startup Team","content":"If you're long enough in the tech business, you should have heard a tale about 3H that every startup needs. In order for a startup to become successful it needs 3 founders:\n- a Hacker\n- a Hustler\n- a Hippie (they call it Hipster nowadays but don't follow the crowd)\n\nIf you think about this setup for a bit, this constellation will definitely start making sense.\n\nLet's see what every one of those `3H` actually entails.\n\n### A Hacker\nLet's start with the easiest one. A Hacker is your CTO - someone who will build the product, someone who cares about building cool products, someone who understands how to spend time efficiently.\n\nSome tend to spend too much time over optimizing the early stage product.\nScalability doesn't matter when you didn't find your product fit yet. When you over optimize too early in the process, you're wasting at least double the time by not executing on your idea, losing time on unnecessary bells and whistles before having found your product market fit.\n\nAs you may know, startup is all about the execution. The faster you can execute, the higher are the chances of your startup to become successful.\n\nSo a hacker should know how to `cut corners` in a smart way. There is a huge difference between your [MVP](https://en.wikipedia.org/wiki/Minimum_viable_product) and your end product.\n\nBuilding products is hard, building valuable products is even harder - that's exactly why every `hacker` needs a counterpart - `a hippie`.\n\n### A Hippie\nWho's a hippie you may ask. If you are too young and don't know who [Steve\nJobs](https://en.wikipedia.org/wiki/Steve_Jobs) was, I pity you and recommend you to start getting to know about him.\n\nUp to this date, I personally consider him to be the best `product person`\never - you can argue, I don't care.\n\nSo, if you haven't seen [The Lost Interview](https://vimeo.com/475108226) yet - do it now, you won't regret it.\n\nOne of the questions Steve was asked is [Are you a hippie or a nerd](https://www.youtube.com/watch?v=uf6TzOHO_dk) - so when the best `product person` of all time considered himself `a hippie`, we can assume that `a hippie` is your `CPO`.\n\n[Marty Cagan](https://svpg.com/our-team/#marty) - the founder of the [Silicon Valley Product Group](https://svpg.com/) has the best definition of a successful product - it emerges on the intersection of following three properties:\n- `Valuable` - Something that our customers will choose to use\n- `Usable` - Easy to figure out how to use\n- `Feasible` - Buildable using the technology stack and skills we have\n\nThe best products exist inside of the transactions of those three\n\n### A Hustler\nThis one is almost as clear as `a hacker` position. Your hustler is your `Head of Sales`. A very important person on your team. Don't be disillusioned - [build it and they will come](https://samuelmullen.com/articles/startup-fallacies-if-you-build-it-they-will-come/) is a fallacy. In the world full of similar products and never ending competition, you need `a hustler` who will sell your product to your customers and your idea to the investors.\n\nThis is the person who knows and believes in your product and help `a hippie` to find the best possible [Product/market fit](https://en.wikipedia.org/wiki/Product/market_fit).\n\n### On A Side-note\n- Ideas are worth nothing without execution\n- Your customers do not care about your tech\n- Startup is a marathon not a sprint - pace yourself\n- Timing matters but you cannot control it\n- You don't know how your product will be used\n- It will be harder than you think\n","excerpt":"If you're long enough in the tech business, you should have heard a tale about 3H that every startup needs. In order for a startup to become successful it needs 3 founders:\n- a Hacker\n- a Hustler\n- a Hippie (they call it Hipster nowadays but don't follow the crowd)\n"},{"slug":"pwa-shortcuts","published":"Sat Apr 17 2021 00:00:00 GMT+0000 (Coordinated Universal Time)","title":"Add shortcuts to your PWA","content":"\nAlthough the end of PWAs has been proclaimed a while ago, the Progressive Web Apps keep getting better.\n\nNot only the processors have been improving at a rapid rate but also the\n[V8 is getting better](https://nodesource.com/blog/why-the-new-v8-is-so-damn-fast/) with every iteration.\n\nSo, if you don't have time to build your mobile app with React Native, Flutter or going full native with Swift or Kotlin - PWA can still be a good low entry barrier option.\n\nThe addition of [maskable icons](https://web.dev/maskable-icon/) let your app finally have a more appealing icon that will be placed on the screen of your mobile phone if you decide to `install` it.\n\nIf you would like to try out the maskable icons, check out the [Maskable\nApp](https://maskable.app/) - it allows you to easily create maskable icons for your app.\n\nWhat can make your app even more appealing and can make it feel even more\n`native`-like are the shortcuts.\n\nShortcuts are accessible through long press on phones and right-clicking on desktop. When a user does a long press, he will see a context menu with links to a certain action of your app.\n\nLet's imagine you build a banking app and you want your users to be able to quickly access the **Transfer Money** screen that's available under `https://my-shiny-bank.io/send-money`\n\nIn order to add this shortcut to your PWA, you have to add the `shortcuts`\nsection to your `manifest.json` file:\n\n```json\n  \"name\": \"BANG\",\n  \"short_name\": \"BANG\",\n  \"description\": \"Neo Bang\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait\",\n  \"background_color\": \"#1B252C\",\n  \"theme_color\": \"#1B252C\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/bang-maskable-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n    {\n      \"src\": \"/icons/bang-maskable-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    }\n  ],\n  \"shortcuts\": [\n    {\n      \"name\": \"Transfer\",\n      \"short_name\": \"Dough Disposal\",\n      \"description\": \"Send some dough to your peeps\",\n      \"url\": \"/send-money\",\n      \"icons\": [\n        {\n          \"src\": \"/img/shortcuts/black/send-money-4x.png\",\n          \"sizes\": \"96x96\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Overview\",\n      \"short_name\": \"My Dough\",\n      \"description\": \"Where is my money?\",\n      \"url\": \"/overview\",\n      \"icons\": [\n        {\n          \"src\": \"/img/shortcuts/black/overview-4x.png\",\n          \"sizes\": \"96x96\"\n        }\n      ]\n    }\n  ]\n}\n```\n\nOnce you added the shortcuts section, the icons you would like to see in your contextual menu and redeployed your app, you should get a result similar to the following:\n\n<div style=\"text-align: center;\">\n  <img src=\"/images/blog/pwa-shortcuts.jpg\" width=\"50%\" />\n</div>\n\nIf your app functionality is hidden behind the authentication don't forget to add the redirection to the shortcuts `\"url\": \"/send-money\"` after a successful authentication.\n\nThe good design should be predictable - so, if your shortcuts represent the menu points of your app, then you should use the same icons both for your shortcuts and in your menu.\n\nIf you're using material design library for your product you can download\nmaterial design icons: [here](https://github.com/material-icons/material-icons-png) or [here](https://www.materialpalette.com/icons)\n\nIf you use [Font Awesome](https://fontawesome.com/) you can use this Font [Awesome 2 PNG](https://fa2png.app/) converter.\n","excerpt":"\nAlthough the end of PWAs has been proclaimed a while ago, the Progressive Web Apps keep getting better.\n\nNot only the processors have been improving at a rapid rate but also the\n[V8 is getting better](https://nodesource.com/blog/why-the-new-v8-is-so-damn-fast/) with every iteration."},{"slug":"graphql-partial-update","published":"Tue Apr 13 2021 00:00:00 GMT+0000 (Coordinated Universal Time)","title":"GraphQL Partial Update","content":"\nRecently we decided to use [AWS Amplify](https://aws.amazon.com/amplify) for one of the products weâ€™re currently working on.\n\n[AWS Amplify](https://aws.amazon.com/amplify) promises to provide you with the option to rapidly develop the [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) or a [GraphQL](https://graphql.org/) based backend that's very well integrated with your frontend development - be it a web application or a mobile app. That's at least the marketed value proposition.\n\nI don't wanna say that's [AWS Amplify](https://aws.amazon.com/amplify) is still in its infancy but let's say it's\nnot without its caveats. One of them is the documentation. In general AWS\nprovides a lot of documentation, which doesn't necessarily means that it's\ngood.\n\nUsually the truly technical documentation like the one for AWS SDK is really\ngood, which is not always the case with the Docs for other services. With AWS\nAmplify it's pretty often the case that the documentation is not up-to-date and\nyou have to dig through the GitHub tickets discussions to find the truth or\nthe undocumented features (yes, `@http resolvers` - I look at you)\n\nIf you have to provide custom headers to your HTTP resolver based GraphQL\noperation - you can send them as part of `API.graphql()` call as last\nparameter, e.g.\n\n```js\nconst headers = {\n  foor: 'bar',\n};\n\nconst response = await API.graphql(\n  graphqlOperation(createFooBar, { body }),\n  headers,\n);\n```\n\nBut I'm drifting away ðŸ˜€\n\nOk, so, we decided to go with GraphQL since in the final iterations the product should have more than just a web application and, theoretically, it should be easier to fetch only the data you need due to the flexible nature of [GraphQL](https://graphql.org/).\n\nSo, if you worked with [AWS Amplify](https://aws.amazon.com/amplify/) and [GraphQL](https://graphql.org/) you know that it doesnâ€™t support partial updates, which was a deal-breaker for us, since we have multiple flows where we have to partially push the data to the backend.\n\nAfter a short research online, I found a pretty cool article from [Arnaud BezanÃ§on](https://medium.com/@arnaud.bezancon) here [https://medium.com/workflowgen/graphql-mutations-partial-updates-implementation-bff586bda989](https://medium.com/workflowgen/graphql-mutations-partial-updates-implementation-bff586bda989)\n\nAlthough I really liked his way of doing things, my lazy nature wanted to have a more generic (not necessarily a better) solution though. So, my way of thinking was: since I only send parts of the data to the backend but it expects the whole { input } object from me, I will just merge the existing data with the new one and push it to the backend.\n\nWhat you have to consider as well is that you will have to remove any automatically generated/updated fields from your `json` object â€” in my case `createdAt/updatedAt` fields.\n\nSo, below you see a quick and dirty way of doing it.\n\nPlease, note that Iâ€™m using email as the key of our user model. In addition to that, you will have to always send the whole user object with all the fields to the update mutation â€” meaning when you call `getUser` it should fetch the user object with all the fields.\n\nIn a nutshell - the flow is the following:\n- try to fetch the user from the backend\n- if the user doesn't exist - call `createUser` with the provided data\n- if the user exist - merge the existing data with the new one and call\n  `updateUser`\n\n```js\nimport { API, graphqlOperation } from 'aws-amplify';\nimport { getUser } from '@/graphql/queries';\nimport { createUser, updateUser } from '@/graphql/mutations';\nimport { exclude } from '@/utils/json';\n\nconst get = async (email) => {\n  try {\n    const {\n      data: {\n        getUser: user,\n      },\n    } = await API.graphql(graphqlOperation(getUser, { email }));\n    return user;\n  } catch (error) {\n    throw new Error(error.errors);\n  }\n};\n\nconst createOrUpdate = async (input) => {\n  const { email } = input;\n  try {\n    const user = await get(email);\n    if (!user) {\n      await API.graphql(graphqlOperation(createUser, { input }));\n    } else {\n      // get current user data\n      // and only update the provided values\n      // createdAt, updatedAt have to be excluded\n      const update = { ...exclude(['createdAt', 'updatedAt'], user), ...input };\n      await API.graphql(graphqlOperation(updateUser, { input: update }));\n    }\n  } catch (error) {\n    throw new Error(error.errors);\n  }\n};\n\nexport {\n  get,\n  createOrUpdate,\n};\n```\n\nSince the email is used as the key of the user model, it has to be passed to the `createOrUpdate` function as part of the `{ input }` object. Whenever I have to create or update a user, we have to add the email to the input and then just call `createOrUpdate(input);`\n\n```js\nconst { email } = user;\nconst input = { email, â€¦payload };\n\ntry {\n  ...\n  await createOrUpdate(input);\n  ...\n} catch (error) {\n  throw new Error(error);\n}\n```\n\nItâ€™s not an efficient way of doing things since it will fetch the data from your backend before doing an update but this way you donâ€™t have to do things manually or thing about the values youâ€™d like to be updated.\n\nThatâ€™s all folks.\n","excerpt":"\nRecently we decided to use [AWS Amplify](https://aws.amazon.com/amplify) for one of the products weâ€™re currently working on.\n\n[AWS Amplify](https://aws.amazon.com/amplify) promises to provide you with the option to rapidly develop the [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) or a [GraphQL](https://graphql.org/) based backend that's very well integrated with your frontend development - be it a web application or a mobile app. That's at least the marketed value proposition.\n"},{"slug":"mock-promisified-aws-sdk-calls","published":"Sat Apr 10 2021 00:00:00 GMT+0000 (Coordinated Universal Time)","title":"Mock promisified AWS service operation calls with Jest","content":"\nAt [Mbanq Cloud](https://mbanq.com/cloud) we run most of our services on AWS and try to use AWS Lambda as much as possible.\n\nA while ago Iâ€™ve been working on the a small npm package that should have helped us to make use of SSM and [KMS](https://aws.amazon.com/kms/) to manage our system configuration. SSM and KMS play nicely together as the most of the AWS services.\n\nIn order to test the newly written npm package, I had to mock the promisified version of the `ssm.getParameters(request)`\n\n```js\nconst AWS = require('aws-sdk')\nconst ssm = AWS.SSM({ region: 'eu-west-1 })\nssm.getParameters(request).promise() // we have to mock the response from this call\n```\n\nThere are different ways of mocking the AWS JS SDK calls. For example there is the [aws-mock-sdk](https://github.com/dwyl/aws-sdk-mock) package from the very cool [DWYL](https://dwyl.com/) guys. I decided to go with pure Jest implementation though.\n\n![](https://cdn-images-1.medium.com/max/2000/1*yZyG4rhfvTehkTsKtLxD9Q.png)\n\nThere are some things to be taken into account to make the SSMâ€™s functionality testable:\n\n- Use **ssm** as a parameter in your function call, e.g. const `load = (ssm, keys, expiryMs)` It will help you to use the mocked ssm whenever you write your tests. Sure you could also `module.exports = { ssm }` alongside other functions you want to export but I didnâ€™t really like this idea\n- If you wanna check for the errors thrown inside of an `async/await` function you have to use: `expect(yourFunc()).rejects.toEqual(new Error('Error Message'))` . The regular `expect(yourFunc()).toThrowError('Error Message')` [**WONâ€™T WORK](https://github.com/facebook/jest/issues/1700#issuecomment-377890222)**\n\nOk, now youâ€™re probably asking yourself:\n> How the heck do you mock the promisified AWS service operation calls?\n\nYou will either want to mock a successful response from the `ssm.getParameters(request).promise()` or the `Error` thrown by the this function call.\n\n### Successful response\nFirst, create a js object with the promise key and mock the value of the promise with the `jest.fn().mockImplementation()` that will return a Promise that when resolved return a successful response.\n\nThen return the created `ssmPromise` whenever you make a call to `getParameters()` function.\n\n```js\nconst AWS = require('aws-sdk')\nlet ssm = new AWS.SSM()\nconst ssmPromise = {\n  promise: jest.fn().mockImplementation((request) => {\n    return new Promise((resolve, reject) => {\n      const response = {\n        Parameters: [\n          {\n            Name: 'bar',\n            Type: 'String',\n            Value: 'barfoorista',\n            Version: 1,\n            LastModifiedDate: '2018-08-22T13:49:55.717Z',\n            ARN: 'arn:aws:ssm:eu-west-1:whatever:parameter/bar'\n          },\n          {\n            Name: 'foo',\n            Type: 'String',\n            Value: 'foobarista',\n            Version: 1,\n            LastModifiedDate: '2018-08-22T13:49:41.486Z',\n            ARN: 'arn:aws:ssm:eu-west-1:whatever:parameter/foo'\n           }\n         ],\n         InvalidParameters: []\n       }\n       resolve(response)\n     })\n  })\n}\nssm = { getParameters: () => { return ssmPromise } }\n```\n\n### Throw an Error\n\nBy using the ssm instance you created at the top of your test, you can also mock the `ssm.getParameters()` in one go.\n\nHere is an example of how you could mock `ssm.getParameters()` throwing an Error\n\n```js\nssm = {\n  getParameters: () => {\n    return {\n      promise: jest.fn().mockImplementation((request) => {\n        return new Promise((resolve, reject) => {\n          return reject(new Error('foobar'))\n        }).catch(() => console.log('Ok'))\n      })\n    }\n  }\n}\n```\n\nIn a [gist](https://gist.github.com/igorkosta/6dae64ca2ababed7bec95255b2252842#file-sreda-test-js) (pun intended) you can see part of the test, weâ€™re using to test our package.\n\nHere is the content of the `gist` for you to check out:\n```js\n/* eslint-env jest */\n'use strict'\n\nconst { read, keys } = require('../sreda')\nconst AWS = require('aws-sdk')\nlet ssm = new AWS.SSM()\n\nvar ssmPromise = {\n  promise: jest.fn().mockImplementation((request) => {\n    return new Promise((resolve, reject) => {\n      const response = {\n        Parameters: [\n          {\n            Name: 'bar',\n            Type: 'String',\n            Value: 'barfoorista',\n            Version: 1,\n            LastModifiedDate: '2018-08-22T13:49:55.717Z',\n            ARN: 'arn:aws:ssm:eu-west-1:whatever:parameter/bar'\n          },\n          {\n            Name: 'foo',\n            Type: 'String',\n            Value: 'foobarista',\n            Version: 1,\n            LastModifiedDate: '2018-08-22T13:49:41.486Z',\n            ARN: 'arn:aws:ssm:eu-west-1:whatever:parameter/foo'\n          }\n        ],\n        InvalidParameters: []\n      }\n      resolve(response)\n    })\n  })\n}\nssm = { getParameters: () => { return ssmPromise } }\n\ndescribe('mock AWS.SSM()', () => {\n  beforeAll(async () => {\n    process.env.NODE_ENV = 'production'\n  })\n\n  it(`throws an error if no keys are providerd`, async () => {\n    function throwsErr () {\n      read(ssm, [])\n    }\n    expect(throwsErr).toThrowError(`You need to provide a non-empty array of config keys`)\n  })\n\n  it(`throws an error if some keys are missing`, async () => {\n    expect(keys(ssm, ['foobar'])).rejects.toEqual(new Error(`Missing SSM Parameter Store keys: foobar`))\n  })\n\n  it(`throws an error when ssm is throwing one`, async () => {\n    ssm = {\n      getParameters: () => {\n        return {\n          promise: jest.fn().mockImplementation((request) => {\n            return new Promise((resolve, reject) => {\n              return reject(new Error('foobar'))\n            }).catch(() => console.log('Ok'))\n          })\n        }\n      }\n    }\n    expect(keys(ssm, ['foo'])).rejects.toEqual(new Error(`TypeError: Cannot destructure property \\`Parameters\\` of 'undefined' or 'null'.`))\n  })\n})\n```\n\nThe `sreda` package is in the dev mode. Check it out if you would like to use\nit in you serverless project: https://www.npmjs.com/package/sreda\n\n```bash\nyarn add sreda\n\nnpm i -S sreda\n```\n","excerpt":"\nAt [Mbanq Cloud](https://mbanq.com/cloud) we run most of our services on AWS and try to use AWS Lambda as much as possible.\n\nA while ago Iâ€™ve been working on the a small npm package that should have helped us to make use of SSM and [KMS](https://aws.amazon.com/kms/) to manage our system configuration. SSM and KMS play nicely together as the most of the AWS services.\n"},{"slug":"vue-router","published":"Mon Apr 05 2021 00:00:00 GMT+0000 (Coordinated Universal Time)","title":"Organize your routes with Vue Router","content":"Everyone has its own view on how to organize the routes in a Single-Page Application-weâ€™re not different.\n\nSince weâ€™re using [Vue.js](https://vuejs.org/) in our current project, weâ€™re also using the [Vue Router](https://router.vuejs.org/).\n\nHere I would like to describe the approach we took to organize our router and its routes. We will probably change/improve the current state later on but for now I will describe the [status quo](https://en.wikipedia.org/wiki/Status_quo).\n\n### Folder structure\n\nWe made a couple of iterations on how we want to organize our routes and we will definitely run through a couple of more iterations until weâ€™re fully satisfied.\n\n<div style=\"text-align: center;\">\n  <img src=\"https://cdn-images-1.medium.com/max/2704/1*Pj1ezbBzQnG4NHlD0seaWg.png\" width=\"400px\" />\n</div>\n\nCurrent folder structure we use is pretty straightforward:\n\n* `index.js`- defines the `beforeEach` logic for the routes\n\n* `/routes/public.js` â€” holds all the public routes (e.g. /, /login, /registration etc.)\n\n* `/routes/private.js` â€” has all the routes for the authenticated user\n\n* `/routes/index.js` - just concatenates all the public and private routes and exports them\n\nLetâ€™s walk quickly through every file â€” youâ€™ll see it will all make sense very quickly.\n\n### `src/router/index.js`\n\n`index.js` only holds one root route (you can also go without it). In our case itâ€™s the dashboard route, the user is redirected to once authenticated.\n\nOk, so the most important part of the `index.js` is the `beforeEach` check.\n\nIn our application we have two types of routes:\n\n* the strictly public ones â€” you have to be logged out to visit them\n\n* the private ones - you have to be authenticated to visit them\n\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport store from '@/store/index.js'\nimport routes from '@/router/routes/index.js'\nVue.use(Router)\n\nconst router = new Router({\n  routes: [\n    {\n      path: '/',\n      redirect: '/dashboard'\n    }\n  ].concat(routes)\n})\n\nrouter.beforeEach((to, from, next) => {\n  const authenticated = store.state.user.authenticated\n  const onlyLoggedOut = to.matched.some(record => record.meta.onlyLoggedOut)\n  const isPublic = to.matched.some(record => record.meta.public)\n  if (!isPublic && !authenticated) {\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    return next({\n      path: '/login',\n      query: { redirect: to.fullPath }\n    })\n  }\n  if (authenticated && onlyLoggedOut) {\n    return next('/')\n  }\n  next()\n})\n\nexport default router\n```\n\nAs you can see from the code snippet above, we read the authentication state from the local [Vuex](https://vuex.vuejs.org/) store. Other information that we need to decide whether a route can be visited or not is stored in the [meta field](https://router.vuejs.org/guide/advanced/meta.html) of the routes:\n\n* `onlyLoggedOut` â€” a route can only be visited by a non authenticated user\n\n* `isPublic` - itâ€™s a public route and can be visited without authentication (`/login`, `/registration` etc.)\n\nThere are only two cases (weâ€™d like to keep it simple in the beginning):\n\n* `!isPublic && !authenticated` â€” the user is not authenticated but is trying to access the private route â€” he/sheâ€™ll be redirected to the `/login` page and will be redirected to the page he was trying to access upon successful authentication\n\n* `authenticated && onlyLoggedOut` - the user is authenticated but is trying to access the public page â€” heâ€™ll be redirected back to the dashboard\n\n### `src/router/routes/public.js`\n\nWe were thinking about breaking down the routes and put every one of them into its own file, but, mmm-maybe later :).\n\nOk, so all the public routes are in one file and all of them rock the same meta field:\n\n```js\nmeta: {\n  public: true,\n  onlyLoggedOut: true\n}\n```\n\n```js\nimport Login from '@/views/Login.vue'\nimport Registration from '@/views/Registration.vue'\nimport ForgotPassword from '@/views/ForgotPassword.vue'\n\nconst routes = [\n  {\n    path: '/login',\n    name: 'login',\n    component: Login\n  },\n  {\n    path: '/registration',\n    name: 'registration',\n    component: Registration\n  },\n  {\n    path: '/forgot-password',\n    name: 'forgotPassword',\n    component: ForgotPassword\n  }\n]\n\nexport default routes.map(route => {\n  const meta = {\n    public: true,\n    onlyLoggedOut: true\n  }\n  return { ...route, meta }\n})\n```\n\nIn order to not pollute every route, weâ€™re adding the meta field to all the routes in the file in the export section. This way we donâ€™t have to think about adding the meta field to every new added route.\n\n### `src/router/routes/private.js`\n\nYou know the drill by now. All the private routes reside in one file and the meta field is added to each and one of them in the export section.\n\n```js\nimport Accounts from '@/views/Accounts/Index.vue'\nimport Dashboard from '@/views/Dashboard/Index.vue'\nimport Settings from '@/views/Settings/Index.vue'\n\nconst routes = [\n    {\n    path: '/accounts',\n    name: 'accounts',\n    component: Accounts\n  },\n  {\n    path: '/dashboard',\n    name: 'dashboard',\n    component: Dashboard\n  },\n  {\n    path: '/settings',\n    name: 'settings',\n    component: Settings\n  }\n]\n\nexport default routes.map(route => {\n  return { ...route, meta: { public: false } }\n})\n```\n\n### `src/router/routes/index.js`\n\nWhatâ€™s inside of the `routes/index.js` you may ask. Itâ€™s just the utility file that imports the routes from both `public.js` and `private.js` and exports them as one.\n\n```js\nimport publicRoutes from '@/router/routes/public.js'\nimport privateRoutes from '@/router/routes/private.js'\n\nexport default publicRoutes.concat(privateRoutes)\n```\n\nThis file is not necessary, you could just import public and private routes directly into the `src/router/index.js`\n\nThat's all folks!\n","excerpt":"Everyone has its own view on how to organize the routes in a Single-Page Application-weâ€™re not different.\n\nSince weâ€™re using [Vue.js](https://vuejs.org/) in our current project, weâ€™re also using the [Vue Router](https://router.vuejs.org/).\n\nHere I would like to describe the approach we took to organize our router and its routes. We will probably change/improve the current state later on but for now I will describe the [status quo](https://en.wikipedia.org/wiki/Status_quo)."}]},"__N_SSG":true}